"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RESTcli = void 0;
const index_1 = require("../index");
const qs = require("querystring");
const BitPayException_1 = require("../Exceptions/BitPayException");
const axios = require("axios").default;
class RESTcli {
    constructor(environment, ecKey) {
        this._keyUtils = new index_1.KeyUtils();
        this._ecKey = ecKey;
        this._baseUrl =
            environment.toUpperCase() == index_1.Env.Test ? index_1.Env.TestUrl : index_1.Env.ProdUrl;
        this.init();
    }
    async post(uri, formData = {}, signatureRequired = true) {
        try {
            const _fullURL = this._baseUrl + uri;
            const _formData = JSON.stringify(formData);
            const _options = JSON.parse(JSON.stringify(this._commonOptions));
            _options.uri = _fullURL;
            _options.body = JSON.parse(JSON.stringify(formData));
            if (signatureRequired) {
                Object.assign(_options.headers, this.getSignedHeaders(_fullURL, _formData));
            }
            return await axios({
                method: "post",
                url: _options.uri,
                headers: _options.headers,
                data: _options.body,
            })
                .then((resp) => resp.data)
                .then((resp) => {
                return this.responseToJsonString(resp.data);
            });
        }
        catch (e) {
            throw new BitPayException_1.default(null, "RESTcli POST failed: " + JSON.stringify(e.response.data));
        }
    }
    async get(uri, parameters = {}, signatureRequired = true) {
        try {
            const _fullURL = this._baseUrl + uri;
            const _options = JSON.parse(JSON.stringify(this._commonOptions));
            const _query = "?" + qs.stringify(parameters);
            _options.uri = _fullURL;
            _options.qs = parameters;
            if (signatureRequired) {
                Object.assign(_options.headers, this.getSignedHeaders(_fullURL, _query));
            }
            return await axios({
                method: "get",
                url: _options.uri,
                headers: _options.headers,
                data: _options.body,
                params: _options.qs,
            })
                .then((resp) => resp.data)
                .then((resp) => {
                return this.responseToJsonString(resp.data);
            });
        }
        catch (e) {
            throw new BitPayException_1.default(null, "RESTcli GET failed : " + JSON.stringify(e.response.data));
        }
    }
    async delete(uri, parameters = {}) {
        try {
            const _fullURL = this._baseUrl + uri;
            const _options = JSON.parse(JSON.stringify(this._commonOptions));
            const _query = "?" + qs.stringify(parameters);
            Object.assign(_options.headers, this.getSignedHeaders(_fullURL, _query));
            _options.uri = _fullURL;
            _options.qs = parameters;
            return await axios({
                method: "delete",
                url: _options.uri,
                headers: _options.headers,
                data: _options.body,
                params: _options.qs,
            })
                .then((resp) => resp.data)
                .then((resp) => {
                return this.responseToJsonString(resp.data);
            });
        }
        catch (e) {
            throw new BitPayException_1.default(null, "RESTcli DELETE failed : " + JSON.stringify(e.response.data));
        }
    }
    async update(uri, formData = {}) {
        try {
            const _fullURL = this._baseUrl + uri;
            const _formData = JSON.stringify(formData);
            const _options = JSON.parse(JSON.stringify(this._commonOptions));
            Object.assign(_options.headers, this.getSignedHeaders(_fullURL, _formData));
            _options.uri = _fullURL;
            _options.body = formData;
            return await axios({
                method: "put",
                url: _options.uri,
                headers: _options.headers,
                data: _options.body,
                params: _options.qs,
            })
                .then((resp) => resp.data)
                .then((resp) => {
                return this.responseToJsonString(resp.data);
            });
        }
        catch (e) {
            throw new BitPayException_1.default(null, "RESTcli UPDATE failed : " + JSON.stringify(e.response.data));
        }
    }
    async responseToJsonString(response) {
        try {
            if (response == null) {
                throw new BitPayException_1.default(null, "Error: HTTP response is null");
            }
            let responsObj = JSON.parse(JSON.stringify(response));
            if (responsObj.hasOwnProperty("status")) {
                if (responsObj["status"] === "error") {
                    throw new BitPayException_1.default(null, "Error: " + responsObj["error"], null, responsObj["code"]);
                }
            }
            if (responsObj.hasOwnProperty("error")) {
                throw new BitPayException_1.default(null, "Error: " + responsObj["error"]);
            }
            else if (responsObj.hasOwnProperty("errors")) {
                let message = "";
                responsObj["errors"].forEach(function (error) {
                    message += "\n" + error.toString();
                });
                throw new BitPayException_1.default(null, "Errors: " + message);
            }
            if (responsObj.hasOwnProperty("success")) {
                return JSON.stringify(responsObj["success"]);
            }
            if (responsObj.hasOwnProperty("data")) {
                return JSON.stringify(responsObj["data"]);
            }
            return JSON.stringify(responsObj);
        }
        catch (e) {
            throw new BitPayException_1.default(null, "failed to retrieve HTTP response body : " + e.message);
        }
    }
    init() {
        try {
            this._identity = this._keyUtils.getPublicKeyFromPrivateKey(this._ecKey);
            this._commonOptions = {
                headers: {
                    "x-accept-version": index_1.Env.BitpayApiVersion,
                    "x-bitpay-plugin-info": index_1.Env.BitpayPluginInfo,
                    "x-bitpay-api-frame": index_1.Env.BitpayApiFrame,
                    "x-bitpay-api-frame-version": index_1.Env.BitpayApiFrameVersion,
                    "Content-Type": "application/json",
                },
                json: true,
            };
        }
        catch (e) {
            throw new BitPayException_1.default(null, "RESTcli init failed : " + e.message);
        }
    }
    getSignedHeaders(uri, formData) {
        return {
            "x-identity": this._identity,
            "x-signature": this._keyUtils.sign(uri + formData, this._ecKey),
        };
    }
}
exports.RESTcli = RESTcli;
//# sourceMappingURL=RESTcli.js.map